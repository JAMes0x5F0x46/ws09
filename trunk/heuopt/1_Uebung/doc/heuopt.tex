\documentclass[a4paper,10pt]{article}

\usepackage{ngerman}

%opening
\title{Heuristische Optimierungsverfahren \\ \bigskip \textbf{1.Programmier\"{u}bung}}
\author{Johannes Reiter, Christian Gruber}
\date{\vspace{1cm} 01.Dezember 2009}

\begin{document}

\maketitle

\section{Tool Switching Problem}
Gegeben ist eine Menge von Jobs, die zu ihrer Abarbeitung jeweils einen gewissen Satz von Tools ben\"{o}tigt.
Da nicht alle Tools gemeinsam in das Magazin der Maschine passen (max. Anzahl entspricht der Magazingr\"{o}"se), ist
nun eine m\"{o}glichst g\"{u}nstige Reihenfolge der Jobs gesucht, in der die Anzahl der Tool Switches minimiert wurde.
Die L\"{o}sung zu einer Test-Instanz eines Tool Switching Problems ist nun eine Permutation in der alle Jobs abgearbeitet
werden und eine dazu passende Sequenz von Magazin-Konfigurationen.

\subsection{Tool-Konfiguration f\"{u}r eine vorgegebene Reihenfolge}
Gesucht ist hier eine möglichst optimale Magazin-Konfiguration f\"{u}r eine vorgegebene Reihenfolge f\"{u}r die Abarbeitung der Jobs. In diesem Spezialfall kann man nun ausnutzen, dass der Algorithmus genau wei"s wann ein Tool das n\"{a}chste Mal ben\"{o}tigt wird und somit zu der vorgegebenen Reihenfolge die optimale Tool-Konfiguration erzeugen kann.

\subsection{Konstruktionsheuristik}
Unsere Konstruktionsheuristik w\"{a}hlt am Beginn zuf\"{a}llig den ersten Job aus. Die weiteren Jobs werden so gew\"{a}hlt, dass möglichst wenig Kosten entstehen. D.h. der Algorithmus sieht sich alle noch offenen Jobs an und vergleicht die ben\"{o}tigten Tools mit der aktuellen Magazin-Konfiguration.

\subsection*{Results}


\begin{tabular}{cccccc}
\hline
test & k & objective & running  & branch-and-bound & optimum    \\
instance & & function value & time & nodes & node  \\
\hline
fad-01.dat & 6 & 629 & 0.02s &  &   \\
 & 3 & 113 & 0.04s &  &   \\
fad-02.dat & 11 & 1575 & 0.88s & 500 & 406  \\
 & 6 & 716 & 0.44s & 300 & 285 \\
fad-03.dat & 26 & &  & &   \\
 & 11 & 903 & 63.56s & 12300 & 7124  \\
fad-04.dat & 36 & &  &  &   \\
 & 15 & 972 & 6330s & 530900 &  \\
fad-05.dat & 51 & &  & &  \\
 & 21 & &  &  &   \\
fad-06.dat & 101 & &  &  &   \\
 & 41 & &  &  &   \\
\hline
\end{tabular}

\bigskip

\section{Cycle Elimination Formulation}

Der Vorteil der Cycle Elimination Formulierung ist, dass wir nicht exponentiell viele
Ungleichungen benoetigen. Diese werden quasi on-demand, also falls ein Zyklus gefunden wird,
ueber eine Callbackfunktion hinzugefuegt, die in jedem Branch-Node aufgerufen wird.
Um Zyklen zu finden werden bei jeder Kante $e={u,v}$ einmal die Kosten auf unendlich 
gesetzt und dann versucht den kuerzesten Pfad zwischen den Knoten $u$ und $v$ zu finden. 
Wenn jetzt $\sum_{e \in \delta(C)} (1 - x_e) < 1$ (wobei C der gefundene Pfad plus die Kante $e$ ist), 
dann wird ein Cut generiert und die Nebenbedingung (12) hinzugefuegt.
Dieses Verfahren wird fuer alle markierten Kanten in der Loesung wiederholt. \\

\begin{equation}
 min \sum_{e \in E} w_e * x_e
\end{equation}

\begin{equation}
 s.t. \sum_{e \in E} x_e = k - 1
\end{equation}
\begin{equation}
 \sum_{e \in \delta(C)} (1 - x_e) \geq 1
\end{equation}
Mit der folgenden Gleichung wird ueber $z_V$ sichergestellt, dass 
genau $k$ Knoten ausgewaehlt werden muessen.
\begin{equation}
 \sum_{v \in V} z_v = k
\end{equation}
Falls eine Kante $e$ ausgewaehlt wurde, muss auch der jeweilige Anfangs- bzw. Endknoten
durch die Entscheidungsvariable $z_v$ markiert sein.
\begin{eqnarray}
 x_{(u,v)} \leq z_u \qquad \forall (u,v) \in E \nonumber \\
 x_{(u,v)} \leq z_v \qquad \forall (u,v) \in E
\end{eqnarray}

\begin{equation}
 x_e \in \{0,1\} \qquad \forall e \in E
\end{equation}
\begin{equation}
 z_v \in \{0,1\} \qquad \forall v \in V
\end{equation}

\subsection*{Results}

\begin{tabular}{ccccccc}
\hline
test & k & objective & running  & branch-and-bound & optimum & separated   \\
instance & & function value & time & nodes & node & cuts \\
\hline
fad-01.dat & 6 & 629 & 0.02s & & &  \\
 & 3 & 113 & 0.03s &  & &  \\
fad-02.dat & 11 & 1575 & 0.06s &  & & 14  \\
 & 6 & 716 & 0.1s & 2 & 2 &  \\
fad-03.dat & 26 & 3182 & 1.85s & 34 & 34 & 30 \\
 & 11 & 903 & 0.09s & & & 15 \\
fad-04.dat & 36 & 3469 & 0.84s & 3 & 3 & 23 \\
 & 15 & 972 & 0.43s & & & 44 \\
fad-05.dat & 51 & 5000 & 26.84s & 100 & 97 & 37 \\
 & 21 & 1322 & 0.42s &  & & 2 \\
fad-06.dat & 101 & 6790 & 628s & 505 & 505 & 109 \\
 & 41 & 1997 & 3.31s & & & 8 \\
\hline
\end{tabular}

\end{document}
